<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DXNPot â€” Burn XEN Â· Mint & Stake DXN</title>
  <meta name="description" content="DXNPot â€” Burn XEN to mint DXN, auto-stake, claim ETH fees, and manage DXN staking on Ethereum.">
  <link rel="icon" type="image/png" href="/favicon.png">

  <!-- DXNPot fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#050814;

      --cardTop: rgba(13, 19, 34, .78);
      --cardBot: rgba(2, 6, 23, .72);

      --stroke: rgba(255,255,255,.085);
      --stroke2: rgba(255,255,255,.06);

      --txt:#e5e7eb;
      --muted:#a3aab7;
      --muted2:#7c8596;

      --yellow:#facc15;
      --yellow2:#f59e0b;
      --black:#000;

      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --shadow2: 0 10px 28px rgba(0,0,0,.35);

      --r16: 18px;
      --r12: 14px;
      --r10: 12px;

      /* Burn-page legacy colors kept */
      --line: rgba(148,163,184,.22);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }

    body{
      margin:0;
      font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--txt);
      background: url("/dxn-bg.png") center / cover no-repeat fixed;
      padding: 22px 22px;
    }

    body:before{
      content:"";
      position:fixed; inset:-200px -200px auto -200px;
      height:420px;
      background: radial-gradient(closest-side, rgba(250,204,21,.16), transparent 65%);
      pointer-events:none;
      z-index:-1;
      filter: blur(2px);
    }

    .mono{ font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }

    /* match DXNPot frame sizing */
    .frame{
      width: min(1440px, calc(100vw - 44px));
      max-width: 1440px;
      margin: 0 auto;
      padding: 20px;
      border-radius: 26px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(2,6,23,.38);
      box-shadow: var(--shadow), inset 0 0 0 1px rgba(255,255,255,.03);
      backdrop-filter: blur(12px);
      overflow: hidden;
      position: relative;
      z-index: 0;
    }
    .frame::after{
      content:"";
      position:absolute;
      inset: 0;
      border-radius: 26px;
      pointer-events:none;
      box-shadow:
        0 0 0 1px rgba(255,255,255,.06),
        0 0 120px rgba(250,204,21,.18),
        inset 0 0 60px rgba(250,204,21,.08);
    }

    /* DXNPot top bar */
    /* TOPBAR (match pot page) */
    .topbar{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
    margin-bottom: 18px;
    position: relative;
    z-index: 2;

    /* desktop = one line */
    flex-wrap: nowrap;
    }

    .topRight{
    display:flex;
    gap:12px;
    align-items:center;
    margin-left:auto;
    flex-wrap: nowrap;     /* IMPORTANT: prevents dropping */
    }

    .walletRow{
    display:flex;
    gap:10px;
    align-items:center;
    }

    /* mobile = allow wrapping */
    @media (max-width: 820px){
    .topbar{ flex-wrap: wrap; }
    .topRight{ flex-wrap: wrap; justify-content:flex-end; }
    }


    .walletRow{
        display:flex;
        gap:10px;
        align-items:center;
        }


    .tabs{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
    }

    .tab{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      height: 40px;
      padding: 0 14px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: rgba(2,6,23,.55);
      color: var(--txt);
      text-decoration:none;
      font-weight: 800;
      letter-spacing: .2px;
      transition: transform .12s ease, background .12s ease, border-color .12s ease, opacity .12s ease;
    }
    .tab:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,.14); }
    .tab.active{
      background: linear-gradient(180deg, var(--yellow), var(--yellow2));
      color: #000;
      border: 0;
      box-shadow: 0 10px 22px rgba(250,204,21,.18);
    }

    .pill{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(2,6,23,.55);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
      min-height: 44px;
      white-space:nowrap;
    }

    .dot{
      width: 10px; height: 10px;
      border-radius: 999px;
      background: #60a5fa;
      box-shadow: 0 0 14px rgba(96,165,250,.45);
    }

    #batchInput{
    width: 110px;              /* tweak */
    text-align: center;
    font-weight: 900;
    font-size: 18px;
    height: 44px;
    border-radius: 14px;
    }


    .btn-yellow{
      background: linear-gradient(180deg, var(--yellow), var(--yellow2));
      border: 0;
      color: var(--black);
      font-weight: 900;
      border-radius: 12px;
      padding: 10px 14px;
      cursor:pointer;
      height: 40px;
      box-shadow: 0 10px 22px rgba(250,204,21,.18);
      transition: transform .12s ease, box-shadow .12s ease, filter .12s ease, opacity .12s ease;
    }
    .btn-yellow:hover{ transform: translateY(-1px); filter: brightness(1.02); }
    .btn-yellow:active{ transform: translateY(0px); filter: brightness(.98); }
    .btn-yellow[disabled]{ opacity:.55; cursor:not-allowed; transform:none; }

    /* Burn page layout */
    .title{
      text-align:center;
      font-size: 30px;
      font-weight: 900;
      letter-spacing: -0.3px;
      margin: 16px 0 10px;
      position: relative;
      z-index: 2;
    }

    .subline{
      display:flex;
      justify-content:center;
      gap: 40px;
      font-size: 14px;
      color: var(--muted);
      margin-bottom: 18px;
      flex-wrap:wrap;
      position: relative;
      z-index: 2;
    }

    .subline b{ color: var(--yellow); font-weight:900; }

    /* Totals + History helpers */
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:14px;
    }
    @media (max-width: 1100px){
      .grid{ grid-template-columns: 1fr; }
    }

    .h{
    margin: 0 0 10px;
    font-size: 16px;
    font-weight: 900;
    letter-spacing: .2px;
    }

    .calloutBig{
    border: 1px solid var(--stroke);
    background: rgba(2,6,23,.35);
    border-radius: 14px;
    padding: 12px 14px;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }

    .line{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
    padding: 8px 0;
    border-bottom: 1px solid rgba(255,255,255,.06);
    }
    .line:last-child{ border-bottom: 0; }

    .k{ color: var(--muted); font-weight: 800; }
    .pct{ font-weight: 900; }
    .warn{ color: var(--yellow); }
    .good{ color: #86efac; } /* simple green */


    .card{
      background: linear-gradient(180deg, var(--cardTop), var(--cardBot));
      border: 1px solid var(--stroke);
      border-radius: var(--r16);
      padding: 18px;
      box-shadow: var(--shadow2), inset 0 0 0 1px rgba(255,255,255,.03);
      margin-top: 16px;
      position: relative;
      z-index: 2;
    }

    .card-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom: 12px;
      gap: 10px;
      flex-wrap:wrap;
    }

    .card-header .label{
      font-size: 16px;
      font-weight: 900;
      letter-spacing:.2px;
      color: var(--txt);
    }

    .card-header .maxhint{
      font-size: 12px;
      color: var(--muted2);
      letter-spacing:.3px;
      font-weight: 800;
    }
    .card-header .maxhint b{ color: var(--yellow); }

    .controls{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap: wrap;
    }

    .input{
      width: 82px;
      height: 44px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(2,6,23,.42);
      color: var(--txt);
      text-align:center;
      font-size: 16px;
      font-weight: 800;
      outline:none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
      transition: border-color .12s ease, transform .12s ease;
    }
    .input:focus{ border-color: rgba(250,204,21,.35); transform: translateY(-1px); }

    /* Remove number input arrows (Chrome, Edge, Safari) */
    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
    }

    /* Remove number input arrows (Firefox) */
    input[type="number"] {
    -moz-appearance: textfield;
    }


    .xenbox{
      flex: 1 1 220px;
      height: 44px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(2,6,23,.42);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 18px;
      font-weight: 900;
      letter-spacing:.2px;
      min-width: 220px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }

    .smallnote{
      margin-top: 10px;
      font-size: 13px;
      color: var(--muted);
      font-weight: 650;
    }
    .smallnote.row-between{
      display:flex;
      justify-content: space-between;
      align-items:center;
      width:100%;
      gap: 12px;
      flex-wrap:wrap;
    }

    .divider{
      height:1px;
      background: rgba(255,255,255,.08);
      margin: 12px 0 12px;
    }

    .lines{
      font-size: 14px;
      color: var(--muted);
      line-height: 1.9;
      font-weight: 650;
    }
    .lines .v{ color: var(--yellow); font-weight: 900; }

    .burnbtn{
      margin-top: 14px;
      width: 100%;
      height: 56px;
      border-radius: 14px;
      font-size: 18px;
      font-weight: 900;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 10px;
    }

    .rows{
      margin-top: 14px;
      display:flex;
      flex-direction:column;
      gap: 12px;
      position: relative;
      z-index: 2;
    }

    .rowcard{
      border: 1px solid var(--stroke);
      background: rgba(2,6,23,.55);
      border-radius: 14px;
      padding: 14px 16px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 14px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }

    .rowcard .left{
      font-size: 16px;
      color: var(--txt);
      font-weight: 750;
    }
    .rowcard .left b{ color: var(--yellow); font-weight: 900; }

    .row-actions{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .sub-under{
      margin-top: 8px;
      text-align:right;
      color: var(--muted2);
      font-size: 13px;
      font-weight: 650;
    }

    .bottomlinks{
      text-align:center;
      margin-top: 18px;
      color: var(--muted2);
      font-size: 13px;
      letter-spacing:.2px;
      width: 100%;
      position: relative;
      z-index: 2;
    }

    .bottomlinks a{
      color: var(--muted2);
      text-decoration:none;
      border-bottom: 1px solid rgba(148,163,184,.25);
      padding-bottom: 2px;
      font-weight: 650;
    }
    .bottomlinks a:hover{ color: var(--txt); border-bottom-color: rgba(229,231,235,.35); }

    .copy-pill{
      display:inline-block;
      margin-top:10px;
      padding:8px 12px;
      border-radius:999px;
      background: linear-gradient(180deg, var(--yellow), var(--yellow2));
      color:#000;
      font-weight:900;
      font-size:12px;
      letter-spacing:.2px;
      box-shadow: 0 10px 22px rgba(250,204,21,.18);
    }

    
    .chainWrap{
    position: relative;
    display: inline-flex;  /* IMPORTANT: donâ€™t behave like a big block */
    flex: 0 0 auto;        /* IMPORTANT: donâ€™t stretch */
    }
  
    .chain-item:hover{ background: rgba(255,255,255,.06); }

    .row-between{
      display:flex;
      justify-content: space-between;
      align-items:center;
    }

    .rowcard.stakeRow{ align-items:flex-start; }
    .rowcard.stakeRow .left{ flex: 1; }
    .rowcard.stakeRow .right{
      margin-left:auto;
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:8px;
    }

    @media (max-width: 640px){
      .title{ font-size: 26px; }
      .xenbox{ min-width: 180px; }
    }

    /* =========================
   CHAIN DROPDOWN (FINAL)
   ========================= */

/* Make the glow overlay ALWAYS behind everything */
.frame{
  position: relative;
  isolation: isolate;
}
.frame::after{
  z-index: -1 !important;
  pointer-events: none;
}

/* Force the topbar ABOVE the page cards */
.topbar{
  position: relative;
  z-index: 5000;
}

/* Cards can be normal */
.card, .rows, .grid, .title, .subline, .bottomlinks{
  position: relative;
  z-index: 1;
}

/* Anchor dropdown to pill and keep above everything */
.chainWrap{
  position: relative;
  display: inline-flex;
  flex: 0 0 auto;
  z-index: 99999; /* key */
}

/* Dropdown menu */
#chainMenu{
  display: none;
  position: absolute;
  top: 52px;
  left: 0;

  min-width: 240px;
  padding: 8px;
  border-radius: 12px;
  border: 1px solid var(--stroke);
  background: rgba(2,6,23,.88);
  backdrop-filter: blur(10px);
  box-shadow: 0 10px 30px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.03);

  z-index: 100000; /* key */
}

/* Open state */
#chainMenu.show{ display:block; }

/* Items */
#chainMenu .chain-item{
  display:block;
  width:100%;
  text-align:left;
  padding:10px 12px;
  border:0;
  border-radius:10px;
  background:transparent;
  color:var(--txt);
  cursor:pointer;
  font-size:14px;
  font-weight:650;
}
#chainMenu .chain-item:hover{ background: rgba(255,255,255,.06); }


  </style>
</head>

<body>
  <div class="frame">

    <!-- DXNPot-style topbar w/ tabs -->
    <div class="topbar">
    <div class="tabs">
        <a class="tab" href="/pot/">DXN POT</a>
        <a class="tab active" href="/burn/">BURN XEN</a>
        <a class="tab" href="/litepaper/">OVERVIEW</a>
    </div>

    <div class="topRight">
        <!-- Chain selector wrapper -->
        <div class="chainWrap" id="chainWrap">
        <div class="pill" id="chainPill" title="Chain selector">
            <span class="dot"></span>
            <span id="chainLabel" class="mono" style="font-weight:800;">Ethereum</span>
            <span style="opacity:.7;">â–¼</span>
        </div>

        <!-- dropdown menu -->
        <div id="chainMenu" class="chain-menu"></div>
        </div>

        <!-- Wallet pill -->
        <div class="pill">
        <span class="dot"></span>
        <span id="ethBal" class="mono" style="font-weight:800;">â€” ETH</span>
        <span id="addrShort" class="mono" style="opacity:.85;">Not connected</span>
        <button id="connectBtn" class="btn-yellow"
            style="height:40px;padding:0 12px;border-radius:12px;font-weight:900;">
            Connect
        </button>
        </div>
    </div>
    </div>


        <!-- Title MUST be outside topbar -->
        <div class="title">Burn XEN / Mint DXN</div>

        <div class="subline">
        <div>Current Cycle: <b id="cycleNum">â€”</b></div>
        <div>DXN Minted This Cycle: <b id="dxnThisCycle">â€”</b></div>
        <div>Next Cycle In: <b id="nextCycleIn">â€”</b></div>
        </div>


    <!-- burn card -->
    <div class="card">
      <div class="card-header">
        <div class="label">Burn Batches</div>
        <div class="maxhint">MAX: <b>10,000</b> BATCHES</div>
      </div>

      <div class="controls">
        <button id="minusBtn" class="btn-yellow" style="height:44px;border-radius:14px;">âˆ’</button>

        <input
            id="batchInput"
            class="input mono"
            type="number"
            value="1"
            min="1"
            max="10000"
        />

        <button id="plusBtn" class="btn-yellow" style="height:44px;border-radius:14px;">+</button>

        <div class="xenbox mono">
            <span id="xenAmount">2,500,000</span>
            <span style="opacity:.85;">XEN</span>
        </div>

        <button id="maxBtn" class="btn-yellow" style="height:44px;border-radius:14px;">
            â¬† Max
        </button>
        </div>


      <div class="smallnote row-between">
        <span>1 Batch = 2,500,000 XEN</span>
        <span>Your XEN: <b id="yourXen">â€”</b></span>
      </div>

      <div class="divider"></div>

      <div class="lines">
        Protocol Fee : <span id="pf" class="v">~</span><br />
        Total Transaction Cost: <span id="ttc" class="v">~</span><br />
        Total XEN Burned : <span id="totalXenBurned" class="v">2,500,000</span>
      </div>

      <button class="btn-yellow burnbtn">ðŸ”¥ Burn XEN</button>
    </div>

    <!-- rows -->
    <div class="rows">
      <div class="rowcard">
        <div class="left">
          Auto-staked DXN: <b id="autoDxnVal">â€”</b> <span style="opacity:.85;">DXN</span>
        </div>
        <button id="claimDxnBtn" class="btn-yellow" style="min-width:140px;">Claim</button>
      </div>

      <div class="rowcard">
        <div class="left">
          Claimable ETH: <b id="claimableEthVal">â€”</b> <span style="opacity:.85;">ETH</span>
        </div>
        <button id="claimEthBtn" class="btn-yellow" style="min-width:140px;">Claim</button>
      </div>

      <div class="rowcard stakeRow">
        <div class="left" style="padding-top:2px; line-height:1.15;">
          <div>
            Total Staked:
            <b id="totalStakedVal" class="tip" data-tip="Available to withdraw this cycle">â€”</b>
            <span style="opacity:.85;">DXN</span>
          </div>

          <div style="margin-top:6px; color:var(--muted2); font-size:14px;">
            Total Pending:
            <b id="pendingStakedVal" class="tip" data-tip="Locked until next cycle">â€”</b>
            <span style="opacity:.85;">DXN</span>
          </div>
        </div>

        <div class="right">
          <div class="row-actions">
            <input id="stakeAmt" class="input mono" type="number" placeholder="0.0" min="0" step="any" style="width:140px;" />
            <button id="stakeBtn" class="btn-yellow" style="min-width:130px;">Stake</button>
            <button id="unstakeBtn" class="btn-yellow" style="min-width:130px;">Unstake</button>
          </div>
          <div class="sub-under">Your DXN: <span id="yourDxnBal" class="mono">â€”</span> DXN</div>
        </div>
      </div>
    </div>

    <!-- Totals + History -->
<div class="grid" style="margin-top:14px;">
  <!-- Totals card -->
  <div class="card">
    <h3 class="h">Your Totals</h3>

    <div class="calloutBig">
      <div class="line">
        <span class="k">Total XEN Burned</span>
        <span class="pct warn" id="totXen">â€”</span>
      </div>
      <div class="line">
        <span class="k">Total DXN Claimed</span>
        <span class="pct good" id="totDxn">â€”</span>
      </div>
      <div class="line">
        <span class="k">Total ETH Claimed</span>
        <span class="pct warn" id="totEth">â€”</span>
      </div>
    </div>

    <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
      <button class="btn-yellow" id="loadHistoryBtn">Load History</button>
      <span class="mono" style="opacity:.7; align-self:center;" id="historyStatus">Not loaded</span>
    </div>
  </div>

  <!-- History card -->
  <div class="card">
    <h3 class="h">Burn History</h3>

    <div class="calloutBig" style="margin-top:10px;">
      <div class="line" style="justify-content:space-between;">
        <span class="k">Latest burns</span>
        <span class="v mono" id="pageLabel">Page 1</span>
      </div>
    </div>

    <div id="burnRows" style="margin-top:12px; display:flex; flex-direction:column; gap:10px;"></div>

    <div style="margin-top:12px; display:flex; gap:10px; justify-content:flex-end;">
      <button class="btn-yellow" id="prevPageBtn" style="opacity:.85;">â—€ Prev</button>
      <button class="btn-yellow" id="nextPageBtn" style="opacity:.85;">Next â–¶</button>
    </div>
  </div>

  <!-- Total XEN Burned (running total) -->
<div class="card">
  <h3 class="h">Total XEN Burned</h3>

  <div class="calloutBig" style="padding:18px;">
    <div
      id="totXenRun"
      class="mono"
      style="font-size:44px; font-weight:900; letter-spacing:-.5px;"
    >â€”</div>

    <div style="margin-top:6px; color:var(--muted); font-weight:800;">
      Across all detected burns (this wallet)
    </div>
  </div>
</div>

</div>

    <!-- bottom contract links -->
    <div class="bottomlinks">
      <div class="contract-links">
        <a href="#" id="copyXen">XEN Contract</a>
        &nbsp; | &nbsp;
        <a href="#" id="copyDxn">DXN Contract</a>
      </div>

      <div id="copyMsg" class="copy-pill" style="display:none;"></div>
    </div>
    
  </div>

  


  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.4/dist/ethers.umd.min.js"></script>

  <!-- YOUR ORIGINAL JS (UNCHANGED) -->
  <script>
    const NAV_TABS = [
    { label: "DXN POT", href: "/pot/" },
    { label: "BURN XEN", href: "/burn/" },
    { label: "OVERVIEW", href: "/litepaper/" }
    ];

  const ERC20_ABI = [
    "function balanceOf(address) view returns (uint256)",
    "function allowance(address owner, address spender) view returns (uint256)",
    "function approve(address spender, uint256 amount) returns (bool)",
    "function decimals() view returns (uint8)"
  ];

  function wireClaimButtons() {
    const claimDxnBtn = document.getElementById("claimDxnBtn");
    const claimEthBtn = document.getElementById("claimEthBtn");

    console.log("wireClaimButtons:", {
      claimDxnBtn: !!claimDxnBtn,
      claimEthBtn: !!claimEthBtn
    });

    if (claimDxnBtn && !claimDxnBtn.__wired) {
      claimDxnBtn.__wired = true;
      claimDxnBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        if (!signer) return;

        try {
          const gasPrice = await getLegacyGasPriceWei();
          const dbxenWrite = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, signer);

          const tx = await dbxenWrite.claimRewards({ gasPrice, type: 0 });
          await tx.wait();

          await loadClaimables();
        } catch (err) {
          console.log("CLAIM DXN ERROR:", err);
        }
      });
    }

    if (claimEthBtn && !claimEthBtn.__wired) {
      claimEthBtn.__wired = true;
      claimEthBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        if (!signer) return;

        try {
          const gasPrice = await getLegacyGasPriceWei();
          const dbxenWrite = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, signer);

          const tx = await dbxenWrite.claimFees({ gasPrice, type: 0 });
          await tx.wait();

          await loadClaimables();
        } catch (err) {
          console.log("CLAIM ETH ERROR:", err);
        }
      });
    }
  }

  function renderTopbar(activePath) {
    const tabsHtml = NAV_TABS.map(tab => {
        const isActive = activePath === tab.href;
        return `
        <a class="tab ${isActive ? "active" : ""}" href="${tab.href}">
            ${tab.label}
        </a>
        `;
    }).join("");

    return `
        <div class="topbar">
        <div class="tabs">
            ${tabsHtml}
        </div>
        </div>
    `;
    }

    const CHAINS = [
      "ETH",
      "PulseChain",
      "Polygon",
      "BSC",
      "Avalanche",
      "Moonbeam",
      "Dogechain",
      "EthereumPoW",
      "Optimism",
      "Base",
    ];

    const CHAIN_CONFIG = {
      ETH: {
        label: "Ethereum",
        chainIdHex: "0x1",
        chainName: "Ethereum Mainnet",
        rpcUrls: ["https://cloudflare-eth.com"],
        nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
        blockExplorerUrls: ["https://etherscan.io"],
        nativeSymbol: "ETH",

        xen: "0x06450dEe7FD2Fb8E39061434BAbCFC05599a6Fb8",
        dxn: "0x80f0C1c49891dcFDD40b6e0F960F84E6042bcB6F",
        dbxen: "0xF5c80c305803280B587F8cabBcCdC4d9BF522AbD",
        views: "0xf032f7FB8258728A1938473B2115BB163d5Da593",

        xenPerBatch: 2500000,
        supportsStakeClaim: true,
      },

      PulseChain: {
        label: "PulseChain",
        chainIdHex: "0x171",
        chainName: "PulseChain",
        rpcUrls: ["https://rpc.pulsechain.com"],
        nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
        blockExplorerUrls: ["https://otter.pulsechain.com"],
        nativeSymbol: "PLS",

        xen: "0x8a7FDcA264e87b6da72D000f22186B4403081A2a",
        dxn: "0x6fE0ae3D5c993a3073333134db70613B0cb88a31",
        dbxen: "0x6d38Ab9f5b5Edfb22e57a44c3c747f9584de1f1a",
        views: "0x9B560853787B0fB6126F7ad53b63313D2Aa625Db",

        xenPerBatch: 250000000, // keep your value
        supportsStakeClaim: true, // if views is set, claimables can work
      },

      Polygon: {
        label: "Polygon",
        chainIdHex: "0x89",
        chainName: "Polygon",
        rpcUrls: ["https://polygon-rpc.com"],
        nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
        blockExplorerUrls: ["https://polygonscan.com"],
        nativeSymbol: "POL",

        xen: "0x2AB0e9e4eE70FFf1fB9D67031E44F6410170d00e",
        dxn: "0x47DD60FA40A050c0677dE19921Eb4cc512947729",
        dbxen: "0x4F3ce26D9749C0f36012C9AbB41BF9938476c462",
        views: "0x93CC648eE2fBf366DD5d8D354C0946bE6ee4936c",

        xenPerBatch: 2500000,
        supportsStakeClaim: true,
      },

      BSC: {
        label: "BSC",
        chainIdHex: "0x38",
        chainName: "BNB Smart Chain",
        rpcUrls: ["https://bsc-dataseed.binance.org"],
        nativeCurrency: { name: "BNB", symbol: "BNB", decimals: 18 },
        blockExplorerUrls: ["https://bscscan.com"],
        nativeSymbol: "BNB",

        xen: "0x2AB0e9e4eE70FFf1fB9D67031E44F6410170d00e",
        dxn: "0xCcd09b80453335aa914f5d9174984b6586c315EC",
        dbxen: "0x9caf6C4e5B9E3A6f83182Befd782304c7A8EE6De",
        views: "0x6d38Ab9f5b5Edfb22e57a44c3c747f9584de1f1a",

        xenPerBatch: 2500000,
        supportsStakeClaim: true,
      },

      Avalanche: {
        label: "Avalanche C-Chain",
        chainIdHex: "0xA86A",
        chainName: "Avalanche C-Chain",
        rpcUrls: ["https://api.avax.network/ext/bc/C/rpc"],
        nativeCurrency: { name: "Avalanche", symbol: "AVAX", decimals: 18 },
        blockExplorerUrls: ["https://snowtrace.io"],
        nativeSymbol: "AVAX",

        // You pasted ETH addresses for these before â€” keep ONLY what you truly have.
        // If you don't have XEN/DXN addresses for AVAX, set to null and you'll see "â€”".
        xen: null,
        dxn: null,
        dbxen: null,
        views: "0x3DB1CcF6FC69D3265a8Ec2BF8Da0CBF17F6E76fD",

        xenPerBatch: 2500000,
        supportsStakeClaim: true,
      },

      Moonbeam: {
        label: "Moonbeam",
        chainIdHex: "0x504",
        chainName: "Moonbeam",
        rpcUrls: ["https://rpc.api.moonbeam.network"],
        nativeCurrency: { name: "Glimmer", symbol: "GLMR", decimals: 18 },
        blockExplorerUrls: ["https://moonbeam.moonscan.io"],
        nativeSymbol: "GLMR",

        xen: "0xb564A5767A00Ee9075cAC561c427643286F8F4E1",
        dxn: "0xc418B123885d732ED042b16e12e259741863F723",
        dbxen: "0x2A9C55b6Dc56da178f9f9a566F1161237b73Ba66",
        views: "0x72Ec36D3593ba1fc7Aa5dFDc1ADdf551FE599837",

        xenPerBatch: 2500000,
        supportsStakeClaim: true,
      },

      Dogechain: {
        label: "Dogechain",
        chainIdHex: "0x7D0",
        chainName: "Dogechain",
        rpcUrls: ["https://rpc.dogechain.dog"],
        nativeCurrency: { name: "Dogecoin", symbol: "DOGE", decimals: 18 },
        blockExplorerUrls: ["https://explorer.dogechain.dog"],
        nativeSymbol: "DOGE",

        xen: "0x948eed4490833D526688fD1E5Ba0b9B35CD2c32e",
        dxn: "0xc418B123885d732ED042b16e12e259741863F723",
        dbxen: "0x2A9C55b6Dc56da178f9f9a566F1161237b73Ba66",
        views: "0x72Ec36D3593ba1fc7Aa5dFDc1ADdf551FE599837",

        xenPerBatch: 2500000,
        supportsStakeClaim: true,
      },

      EthereumPoW: {
        label: "EthereumPoW",
        chainIdHex: "0x2710",
        chainName: "EthereumPoW",
        rpcUrls: ["https://mainnet.ethereumpow.org"],
        nativeCurrency: { name: "EthereumPoW", symbol: "ETHW", decimals: 18 },
        blockExplorerUrls: ["https://mainnet.ethwscan.com"],
        nativeSymbol: "ETHW",

        xen: "0x2AB0e9e4eE70FFf1fB9D67031E44F6410170d00e",
        dxn: "0xc418B123885d732ED042b16e12e259741863F723",
        dbxen: "0x2A9C55b6Dc56da178f9f9a566F1161237b73Ba66",
        views: "0x72Ec36D3593ba1fc7Aa5dFDc1ADdf551FE599837",

        xenPerBatch: 2500000,
        supportsStakeClaim: true,
      },

      Optimism: {
        label: "Optimism",
        chainIdHex: "0xA",
        chainName: "Optimism",
        rpcUrls: ["https://mainnet.optimism.io"],
        nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
        blockExplorerUrls: ["https://optimistic.etherscan.io"],
        nativeSymbol: "ETH",

        xen: "0xffcbF84650cE02DaFE96926B37a0ac5E34932fa5",
        dxn: "0xc418B123885d732ED042b16e12e259741863F723",
        dbxen: "0x2A9C55b6Dc56da178f9f9a566F1161237b73Ba66",
        views: "0x72Ec36D3593ba1fc7Aa5dFDc1ADdf551FE599837",

        xenPerBatch: 2500000,
        supportsStakeClaim: true,
      },

      Base: {
        label: "Base",
        chainIdHex: "0x2105",
        chainName: "Base",
        rpcUrls: ["https://mainnet.base.org"],
        nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
        blockExplorerUrls: ["https://basescan.org"],
        nativeSymbol: "ETH",

        xen: "0xffcbF84650cE02DaFE96926B37a0ac5E34932fa5",
        dxn: "0x9430A7e6283Fb704Fd1D9302868Bc39d16FE82Ba",
        dbxen: "0x30782c020FE90614f08a863B41CbB07A2D2D94fF",
        views: "0xF3281221bA95af0C5BBcBd2474cE8C090233133b",

        xenPerBatch: 2500000,
        supportsStakeClaim: true,
      },
    };



  let ACTIVE_CHAIN_KEY = "ETH";
  function cfg() { return CHAIN_CONFIG[ACTIVE_CHAIN_KEY] || CHAIN_CONFIG.ETH; }

    function XEN(){ return cfg().xen; }
    function DXN(){ return cfg().dxn; }
    function DBXEN(){ return cfg().dbxen; }
    function VIEWS(){ return cfg().views; }
    function XEN_PER_BATCH_NOW(){ return cfg().xenPerBatch || 2500000; }



  // Chain dropdown (working)
    const chainPill  = document.getElementById("chainPill");
    const chainMenu  = document.getElementById("chainMenu");
    const chainLabel = document.getElementById("chainLabel");

    async function switchChainAndReloadData(chainKey) {
      const c = CHAIN_CONFIG[chainKey];
      if (!c || !window.ethereum) return;

      // 1) switch (or add) the chain in MetaMask
      try {
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: c.chainIdHex }],
        });
      } catch (err) {
        if (err && err.code === 4902) {
          await window.ethereum.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: c.chainIdHex,
              chainName: c.chainName || c.label || chainKey,
              rpcUrls: c.rpcUrls,
              nativeCurrency: c.nativeCurrency,
              blockExplorerUrls: c.blockExplorerUrls
            }],
          });
        } else {
          console.log("Chain switch rejected:", err);
          return;
        }
      }

      // 2) update app active chain + UI label
      ACTIVE_CHAIN_KEY = chainKey;
      chainLabel.textContent = c.label || chainKey;

      // 2.5) IMPORTANT: apply addresses / reader / xenPerBatch for this chain
      applyChainConfig();
      renderXen();       // updates "2,500,000" display using new XEN_PER_BATCH
      syncMaxBtnLabel(); // keeps max/min toggle correct

      // 3) re-create provider/signer on the new chain
      provider = new ethers.BrowserProvider(window.ethereum);

      // get accounts
      const accounts = await provider.send("eth_accounts", []);
      if (!accounts || !accounts.length) {
        connectBtn.style.display = "";
        return;
      }

      signer = await provider.getSigner();
      userAddress = await signer.getAddress();

      // 4) update top right wallet pill + native symbol
      addrShort.textContent = shortAddr(userAddress);

      const balWei = await provider.getBalance(userAddress);
      const sym = (cfg().nativeSymbol || "ETH");
      ethBal.textContent = Number(ethers.formatEther(balWei)).toFixed(4) + " " + sym;

      connectBtn.style.display = "none";

      // 5) reload all numbers (now using correct chain addresses)
      await refreshFees();
      await loadXenBalance();
      await loadCycleStats();
      await loadClaimables();
      await loadStakeInfo();

      wireClaimButtons();
    }



    function renderChainMenu() {
      chainMenu.innerHTML = CHAINS.map(name =>
        `<button class="chain-item" type="button" data-chain="${name}">${name}</button>`
      ).join("");

      chainMenu.querySelectorAll(".chain-item").forEach(btn => {
        btn.addEventListener("click", async (e) => {
          e.preventDefault();
          e.stopPropagation();

          const key = btn.dataset.chain;
          if (!CHAIN_CONFIG[key]) return;

          chainMenu.classList.remove("show");

          // THIS is the only thing that happens on click
          await switchChainAndReloadData(key);
        });
      });
    }



    if (chainPill && chainMenu && chainLabel){
    renderChainMenu();

    chainPill.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        chainMenu.classList.toggle("show");
    });

    document.addEventListener("click", () => {
        chainMenu.classList.remove("show");
    });

    chainMenu.addEventListener("click", (e) => e.stopPropagation());
    }



    let XEN_ADDRESS = "0x06450dee7fd2fb8e39061434babcfc05599a6fb8";
    let DXN_ADDRESS = "0x80f0c1c49891dcfdd40b6e0f960f84e6042bcb6f";

  const copyXen = document.getElementById("copyXen");
  const copyDxn = document.getElementById("copyDxn");
  const copyMsg = document.getElementById("copyMsg");

  function showCopied(text){
    copyMsg.textContent = text;
    copyMsg.style.display = "inline-block";
    copyMsg.style.opacity = "1";

    clearTimeout(window.__copyTimer);
    window.__copyTimer = setTimeout(() => {
      copyMsg.style.opacity = "0";
      setTimeout(() => { copyMsg.style.display = "none"; }, 250);
    }, 1200);
  }

  async function copyToClipboard(addr){
    try{
      await navigator.clipboard.writeText(addr);
      showCopied("Address copied to clipboard");
    }catch(e){
      const ta = document.createElement("textarea");
      ta.value = addr;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      document.body.removeChild(ta);
      showCopied("Address copied to clipboard");
    }
  }

  copyXen.addEventListener("click", (e) => {
    e.preventDefault();
    copyToClipboard(XEN_ADDRESS);
  });

  copyDxn.addEventListener("click", (e) => {
    e.preventDefault();
    copyToClipboard(DXN_ADDRESS);
  });

  let XEN_PER_BATCH = 2500000;
  const MAX_BATCHES = 10000;

  let DBXEN_ADDRESS = "0xF5c80c305803280B587F8cabBcCdC4d9BF522AbD";

  const DBXEN_ABI = [
    "function burnBatch(uint256 batches) payable",
    "function claimFees()",
    "function claimRewards()",
    "function stake(uint256 amount)",
    "function unstake(uint256 amount)",
    "function MAX_BPS() view returns (uint256)",
    "function currentCycle() view returns (uint256)",
    "function getCurrentCycle() view returns (uint256)",
    "function currentCycleReward() view returns (uint256)",
    "function lastCycleReward() view returns (uint256)",
    "function rewardPerCycle(uint256) view returns (uint256)",
    "function accWithdrawableStake(address account) view returns (uint256)",
    "function pendingStake() view returns (uint256)",
    "function pendingStakeWithdrawal() view returns (uint256)",
    "function accRewards(address account) view returns (uint256)",
    "function getAccWithdrawableStake(address staker) view returns (uint256)",
    "function getUnclaimedRewards(address account) view returns (uint256)",
    "function getUnclaimedFees(address account) view returns (uint256)",
    "function calculateCycleReward() view returns (uint256)",
    "function dxnMintedInCycle(uint256 cycle) view returns (uint256)",
    "function accFirstStake(address) view returns (uint256)",
    "function accSecondStake(address) view returns (uint256)",
    "function accStakeCycle(address,uint256) view returns (uint256)",
    "function getUnclaimedRewards(address) view returns (uint256)",
    "function getUnclaimedFees(address) view returns (uint256)",
    "function i_initialTimestamp() view returns (uint256)",
    "function i_periodDuration() view returns (uint256)",
  ];

  let DBXEN_READER_ADDRESS = "0xf032f7FB8258728A1938473B2115BB163d5Da593";
  const DBXEN_READER_ABI = [
    "function dbxen() view returns (address)",
    "function calculateCycleReward() view returns (uint256)",
    "function getUnclaimedFees(address account) view returns (uint256)",
    "function getUnclaimedRewards(address account) view returns (uint256)",
    "function getAccWithdrawableStake(address) view returns (uint256)"
  ];

  function applyChainConfig() {
    const c = cfg();

    if (c.xen) XEN_ADDRESS = c.xen;
    if (c.dxn) DXN_ADDRESS = c.dxn;
    if (c.dbxen) DBXEN_ADDRESS = c.dbxen;

    // THIS is the key:
    DBXEN_READER_ADDRESS = c.views || "";

    XEN_PER_BATCH = c.xenPerBatch || 2500000;

    console.log("applyChainConfig", ACTIVE_CHAIN_KEY, {
      XEN_ADDRESS, DXN_ADDRESS, DBXEN_ADDRESS, DBXEN_READER_ADDRESS, XEN_PER_BATCH
    });
  }




  const FEE_GAS_PAD = 39400n;
  const BATCH_SLOPE = 5n;

  const batchInput = document.getElementById("batchInput");
  const minusBtn = document.getElementById("minusBtn");
  const plusBtn = document.getElementById("plusBtn");
  const maxBtn = document.getElementById("maxBtn");

  const xenAmountEl = document.getElementById("xenAmount");
  const totalXenBurnedEl = document.getElementById("totalXenBurned");

  const pfEl = document.getElementById("pf");
  const ttcEl = document.getElementById("ttc");

  const connectBtn = document.getElementById("connectBtn");
  const addrShort = document.getElementById("addrShort");
  const ethBal = document.getElementById("ethBal");

  const burnBtn = document.querySelector(".burnbtn");

  let provider = null;
  let signer = null;
  let userAddress = null;
  let maxUnstakeWei = 0n;
  let __dxnWalletWei = 0n;
  let __dxnWithdrawableWei = 0n;
  let __cycleTimer = null;
  let __currentCycleNum = null;


  function clampBatches(n) {
    n = Math.floor(Number(n || 1));
    if (n < 1) n = 1;
    if (n > MAX_BATCHES) n = MAX_BATCHES;
    return n;
  }

  function fmtInt(n) {
    return Number(n).toLocaleString("en-US");
  }

  function shortAddr(a) {
    return a ? (a.slice(0, 6) + "â€¦" + a.slice(-4)) : "Not connected";
  }

  function renderXen() {
    const b = clampBatches(batchInput.value);
    batchInput.value = b;

    const xen = b * XEN_PER_BATCH;
    xenAmountEl.textContent = fmtInt(xen);
    totalXenBurnedEl.textContent = fmtInt(xen);
  }
  function syncMaxBtnLabel(){
    const b = clampBatches(batchInput.value);
    if (b >= MAX_BATCHES){
        maxBtn.textContent = "â¬‡ Min";
        maxBtn.dataset.mode = "min";
    } else {
        maxBtn.textContent = "â¬† Max";
        maxBtn.dataset.mode = "max";
    }
    }

    async function setBatches(n){
    batchInput.value = clampBatches(n);
    renderXen();
    syncMaxBtnLabel();
    await refreshFees();
    }


  async function connectWallet() {
    if (!window.ethereum) {
      return;
    }
    provider = new ethers.BrowserProvider(window.ethereum);
    await provider.send("eth_requestAccounts", []);
    signer = await provider.getSigner();
    userAddress = await signer.getAddress();

    addrShort.textContent = shortAddr(userAddress);

    const balWei = await provider.getBalance(userAddress);
    const sym = (cfg()?.nativeSymbol) || "ETH";
    ethBal.textContent =
      Number(ethers.formatEther(balWei)).toFixed(4) + " " + (cfg().nativeSymbol || "ETH");

    connectBtn.style.display = "none";


    await refreshFees();
    await loadXenBalance();
    await loadCycleStats();
    await loadClaimables();
    await loadStakeInfo();

    wireClaimButtons();
  }

  // ===== History via Vercel (Moralis) =====
  const HISTORY_API_BASE = "https://dxnpot-api.vercel.app";

  function apiChainKey() {
    switch (ACTIVE_CHAIN_KEY) {
      case "ETH": return "eth";
      case "Polygon": return "polygon";
      case "PulseChain": return "pulse";
      default: return "eth";
    }
  }

  // Burn method selector for burnBatch(uint256)
  const BURN_METHOD_ID = "0x037c5414";

  function decodeBurnBatches(inputHex){
    try{
      if (!inputHex || inputHex.length < 10) return null;
      if (!inputHex.startsWith(BURN_METHOD_ID)) return null;
      const data = "0x" + inputHex.slice(10);
      const [b] = ethers.AbiCoder.defaultAbiCoder().decode(["uint256"], data);
      return Number(b);
    }catch{
      return null;
    }
  }

  function dayTimeFromIso(iso){
    try { return new Date(iso).toLocaleString(); } catch { return "â€”"; }
  }

  function fmtNum(n){ return Number(n).toLocaleString("en-US"); }

  let __burnPage = 1;
  const __burnPageSize = 10;

  function renderBurnRows(rows){
    const wrap = document.getElementById("burnRows");
    if (!wrap) return;
  
    if (!rows || rows.length === 0){
      wrap.innerHTML = `<div class="calloutBig"><div class="line"><span class="v">No XEN burns found for this wallet.</span></div></div>`;
      return;
    }
  
    wrap.innerHTML = rows.map(r => `
      <div class="calloutBig">
        <div class="line" style="justify-content:space-between;">
          <span class="k">${(r.ts || "").replace("T"," ").replace(".000Z"," UTC")}</span>
          <a class="mono" style="color:var(--yellow); text-decoration:none;"
             href="${r.url || `https://etherscan.io/tx/${r.hash}`}" target="_blank" rel="noreferrer">View tx</a>
        </div>
        <div class="line" style="gap:14px;">
          <span class="v">Batches:</span> <span class="pct warn">${fmtNum(r.batches)}</span>
          <span class="v">XEN:</span> <span class="pct warn">${fmtNum(r.xen)}</span>
        </div>
      </div>
    `).join("");
  }

  console.log("scope check BEFORE loadHistory:", typeof renderBurnRows);

  async function loadHistory(){
    const status = document.getElementById("historyStatus");
    const pageLabelEl = document.getElementById("pageLabel");
  
    const norm = (a) => String(a || "").toLowerCase();
    const ZERO_ADDR = "0x0000000000000000000000000000000000000000";
  
    function pickTs(x){
      return x?.block_timestamp || x?.blockTimestamp || x?.timestamp || x?.ts || x?.block_time || "";
    }
  
    function txLink(hash){
      const base = (cfg()?.blockExplorerUrls?.[0] || "https://etherscan.io").replace(/\/$/, "");
      return `${base}/tx/${hash}`;
    }
  
    status.textContent = "Loadingâ€¦";
  
    try {
      if (!userAddress) throw new Error("no_wallet");
  
      // âœ… use active chain, not hardcoded eth
      const chainKey = apiChainKey();
      const url = `${HISTORY_API_BASE}/api/history?chain=${encodeURIComponent(chainKey)}&address=${encodeURIComponent(userAddress)}`;
      const r = await fetch(url);
      const data = await r.json();
  
      if (!data || data.ok !== true) throw new Error("history api failed");
  
      const erc20 = Array.isArray(data.erc20) ? data.erc20 : [];
  
      const user = norm(userAddress);
      const xenToken = norm(XEN_ADDRESS);
      const dxnToken = norm(DXN_ADDRESS);
      const dbxen = norm(DBXEN_ADDRESS);
  
      // âœ… burns = XEN token transfer user -> ZERO
      const burnsAll = erc20
        .filter(t =>
          norm(t.token_address || t.address) === xenToken &&
          norm(t.from_address || t.from) === user &&
          norm(t.to_address || t.to) === norm(ZERO_ADDR) &&
          BigInt(t.value || "0") > 0n
        )
        .map(t => {
          const burnedWei = BigInt(t.value || "0");
          // XEN is 18 decimals
          const burnedXenStr = ethers.formatUnits(burnedWei, 18); // string
          const burnedXen = Number(burnedXenStr); // ok for your UI totals
          const batches = Math.floor(burnedXen / XEN_PER_BATCH);
  
          return {
            hash: t.transaction_hash,
            ts: pickTs(t),
            batches,
            xen: Math.floor(burnedXen) // integer display
          };
        })
        .sort((a,b) => String(pickTs(b)).localeCompare(String(pickTs(a))));
  
      // âœ… totals
      const totalXen = burnsAll.reduce((s, r) => s + (r.xen || 0), 0);
      document.getElementById("totXen").textContent = fmtNum(totalXen);
      document.getElementById("totXenRun").textContent = fmtNum(totalXen);
  
      // âœ… dxn claimed = DXN transfer DBXEN -> user
      let dxnWei = 0n;
      for (const t of erc20){
        const token = norm(t.token_address || t.address);
        const to = norm(t.to_address || t.to);
        const from = norm(t.from_address || t.from);
        if (token !== dxnToken) continue;
        if (to !== user) continue;
        if (from !== dbxen) continue;
        dxnWei += BigInt(t.value || "0");
      }
      document.getElementById("totDxn").textContent = fmtDXN6(dxnWei);
  
      // leave ETH claimed placeholder for now
      document.getElementById("totEth").textContent = "â€”";
  
      // âœ… pagination
      const startIdx = (__burnPage - 1) * __burnPageSize;
      const pageRows = burnsAll.slice(startIdx, startIdx + __burnPageSize);
  
      // small improvement: renderBurnRows uses etherscan hardcoded; patch links here by injecting url
      const rowsWithUrl = pageRows.map(r => ({ ...r, url: txLink(r.hash) }));
      renderBurnRows(rowsWithUrl);
  
      if (pageLabelEl) pageLabelEl.textContent = `Page ${__burnPage}`;
      status.textContent = "Loaded";
    } catch (e) {
      console.log("loadHistory error:", e);
      status.textContent = "Error loading (check console)";
    }
  }



  // Wire buttons (no paging yet)
  document.getElementById("loadHistoryBtn")?.addEventListener("click", async () => {
    if (!userAddress) { alert("Connect wallet first"); return; }
    __burnPage = 1;
    await loadHistory();
  });

  // Prev / Next paging
  document.getElementById("prevPageBtn")?.addEventListener("click", async (e) => {
    e.preventDefault();
    if (__burnPage > 1) __burnPage--;
    await loadHistory();
  });
  
  document.getElementById("nextPageBtn")?.addEventListener("click", async (e) => {
    e.preventDefault();
    __burnPage++;
    await loadHistory();
  });





  async function loadStakeInfo() {
    const totalEl = document.getElementById("totalStakedVal");
    const pendingEl = document.getElementById("pendingStakedVal");
    const balEl = document.getElementById("yourDxnBal");

    if (totalEl) totalEl.textContent = "â€¦";
    if (pendingEl) pendingEl.textContent = "â€¦";
    if (balEl) balEl.textContent = "â€¦";

    if (!provider || !userAddress) {
      if (totalEl) totalEl.textContent = "â€”";
      if (pendingEl) pendingEl.textContent = "â€”";
      if (balEl) balEl.textContent = "â€”";
      return;
    }

    // DXN wallet balance works without reader
    try {
      const dxn = new ethers.Contract(DXN_ADDRESS, ERC20_ABI, provider);
      const bal = await dxn.balanceOf(userAddress);
      __dxnWalletWei = bal;
      if (balEl) balEl.textContent = fmtDXN6(bal);
    } catch (e) {
      console.log("DXN balance failed:", e);
      if (balEl) balEl.textContent = "â€”";
    }

    // stake numbers require reader/views
    if (!DBXEN_READER_ADDRESS) {
      if (totalEl) totalEl.textContent = "â€”";
      if (pendingEl) pendingEl.textContent = "â€”";
      return;
    }

    try {
      const reader = new ethers.Contract(DBXEN_READER_ADDRESS, DBXEN_READER_ABI, provider);
      const withdrawable = await reader.getAccWithdrawableStake(userAddress);

      __dxnWithdrawableWei = withdrawable;
      maxUnstakeWei = withdrawable;

      if (totalEl) totalEl.textContent = fmtDXN6(withdrawable);
      if (pendingEl) pendingEl.textContent = fmtDXN6(0n); // you don't have pending wired yet
    } catch (e) {
      console.log("loadStakeInfo failed:", e);
      if (totalEl) totalEl.textContent = "â€”";
      if (pendingEl) pendingEl.textContent = "â€”";
    }
  }


  async function loadCycleStats() {
    const cycleEl = document.getElementById("cycleNum");
    const mintedEl = document.getElementById("dxnThisCycle");

    if (cycleEl) cycleEl.textContent = "â€¦";
    if (mintedEl) mintedEl.textContent = "â€¦";

    if (!provider) {
      if (cycleEl) cycleEl.textContent = "â€”";
      if (mintedEl) mintedEl.textContent = "â€”";
      return;
    }

    // currentCycle is on DBXEN (might not exist on chains where DBXEN address is wrong)
    try {
      const dbxen = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, provider);
      const cycle = await dbxen.currentCycle.staticCall();
      __currentCycleNum = cycle;
      if (cycleEl) cycleEl.textContent = cycle.toString();
      await startNextCycleCountdown();
    } catch (e) {
      console.log("currentCycle() failed:", e);
      if (cycleEl) cycleEl.textContent = "â€”";
      if (mintedEl) mintedEl.textContent = "â€”";
      return;
    }

    // mintedThisCycle requires reader/views
    if (!DBXEN_READER_ADDRESS) {
      if (mintedEl) mintedEl.textContent = "â€”";
      return;
    }

    try {
      const reader = new ethers.Contract(DBXEN_READER_ADDRESS, DBXEN_READER_ABI, provider);
      const rewardWei = await reader.calculateCycleReward();
      if (mintedEl) mintedEl.textContent = fmtDXN6(rewardWei);
    } catch (e) {
      console.log("calculateCycleReward (reader) failed:", e);
      if (mintedEl) mintedEl.textContent = "â€”";
    }
  }


  async function loadClaimables() {
    const dxnEl = document.getElementById("autoDxnVal");
    const ethEl = document.getElementById("claimableEthVal");

    if (dxnEl) dxnEl.textContent = "â€¦";
    if (ethEl) ethEl.textContent = "â€¦";

    if (!provider || !userAddress) {
      if (dxnEl) dxnEl.textContent = "â€”";
      if (ethEl) ethEl.textContent = "â€”";
      return;
    }

    if (!DBXEN_READER_ADDRESS) {
      if (dxnEl) dxnEl.textContent = "â€”";
      if (ethEl) ethEl.textContent = "â€”";
      return;
    }

    try {
      const reader = new ethers.Contract(DBXEN_READER_ADDRESS, DBXEN_READER_ABI, provider);
      const feesWei = await reader.getUnclaimedFees(userAddress);
      const rewardsWei = await reader.getUnclaimedRewards(userAddress);

      if (dxnEl) dxnEl.textContent = fmtDXN6(rewardsWei);

      const sym = (cfg().nativeSymbol || "ETH");
      if (ethEl) ethEl.textContent = `${fmtETH6(feesWei)} ${sym}`;
    } catch (e) {
      console.log("loadClaimables failed:", e);
      if (dxnEl) dxnEl.textContent = "â€”";
      if (ethEl) ethEl.textContent = "â€”";
    }
  }


  async function loadXenBalance(){
    const el = document.getElementById("yourXen");
    if (!el) return;

    el.textContent = "â€¦";

    try{
      if (!provider || !userAddress) { el.textContent = "â€”"; return; }

      const xen = new ethers.Contract(XEN_ADDRESS, ERC20_ABI, provider);
      const decimals = await xen.decimals();
      const bal = await xen.balanceOf(userAddress);

      el.textContent = Number(ethers.formatUnits(bal, decimals)).toLocaleString();
    }catch(err){
      console.log("XEN BAL ERROR:", err);
      el.textContent = "ERR";
    }
  }

  async function getGasPriceWei() {
    const hex = await provider.send("eth_gasPrice", []);
    return BigInt(hex);
  }

  async function calcDbxenFee(batches) {
    const dbxenRead = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, provider);
    const maxBps = await dbxenRead.MAX_BPS();
    const b = BigInt(batches);
    const discount = b * (maxBps - (BATCH_SLOPE * b));
    const gasPrice = await getGasPriceWei();
    if (!gasPrice) throw new Error("No gasPrice");
    // MetaMask estimateGas is flaky (-32603). Use a stable fallback.
    let gasUsed = 220000n;

    const protocolFee =
      ((gasUsed + FEE_GAS_PAD) * gasPrice * discount) / maxBps;

    const totalCost = protocolFee + (gasUsed * gasPrice);

    return { protocolFee, totalCost };
  }

  function fmtEth(wei) {
    try {
      const s = ethers.formatEther(wei);
      const n = Number(s);
      if (!isFinite(n)) return "~";
      return n.toFixed(5);
    } catch {
      return "~";
    }
  }

  function fmtETH6(wei) {
    try {
      const s = ethers.formatEther(wei);
      const [i, d = ""] = s.split(".");
      return `${i}.${d.slice(0, 6).padEnd(6, "0")}`;
    } catch {
      return "~";
    }
  }

  function fmtDXN6(wei) {
    try {
      const s = ethers.formatUnits(wei, 18);
      const [i, d = ""] = s.split(".");
      return `${i}.${d.slice(0, 6).padEnd(6, "0")}`;
    } catch {
      return "~";
    }
  }

  // ===============================
  // NEXT CYCLE COUNTDOWN (DBXEN)
  // (safe version: no contract calls)
  // ===============================
  function fmtHMS(totalSec){
    const s = Math.max(0, Math.floor(totalSec));
    const h = String(Math.floor(s / 3600)).padStart(2, "0");
    const m = String(Math.floor((s % 3600) / 60)).padStart(2, "0");
    const ss = String(s % 60).padStart(2, "0");
    return `${h}:${m}:${ss}`;
  }

  async function startNextCycleCountdown(){
    const el = document.getElementById("nextCycleIn");
    if (!el) return;

    if (__cycleTimer) clearInterval(__cycleTimer);

    if (!provider || __currentCycleNum == null){
      el.textContent = "â€”";
      return;
    }

    let baseTs = 0;      // chain timestamp (sec)
    let baseLocal = 0;   // local time (ms)
    let genesis = 1679493611; // fallback (YOU confirmed this in console)
    const DAY = 86400;

    // IMPORTANT: call i_initialTimestamp() on the REAL DBXEN contract
    const GENESIS_ABI = ["function i_initialTimestamp() view returns (uint256)"];

    async function syncAll(){
      try{
        const blk = await provider.getBlock("latest");
        baseTs = Number(blk.timestamp);
        baseLocal = Date.now();
      }catch(e){
        console.log("countdown block sync failed:", e);
        baseTs = 0;
        return;
      }

      // Try reading genesis from DBXEN contract (if it exists)
      try{
        const g = new ethers.Contract(DBXEN_ADDRESS, GENESIS_ABI, provider);
        const v = await g.i_initialTimestamp();
        genesis = Number(v);
      }catch(e){
        // keep fallback genesis
        console.log("i_initialTimestamp() failed, using fallback genesis:", e);
      }
    }

    function secondsToNext(nowTs){
      // next cycle boundary based on genesis + (cycle+1)*DAY
      const next = genesis + (Number(__currentCycleNum) + 1) * DAY;
      return next - nowTs;
    }

    await syncAll();

    __cycleTimer = setInterval(async () => {
      if (!baseTs){
        el.textContent = "â€”";
        return;
      }

      const elapsed = Math.floor((Date.now() - baseLocal) / 1000);
      const nowTs = baseTs + elapsed;

      el.textContent = fmtHMS(secondsToNext(nowTs));

      // resync once per minute
      if (elapsed % 60 === 0) await syncAll();
    }, 1000);
  }



  // DBXen Burn event topic0 (Burn(indexed user, uint256 batches))
    const DBXEN_BURN_TOPIC0 = "0xcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5";
    const DBXEN_FROM_BLOCK = 16883586; // DBXen creation block

    const PAGE_SIZE = 10;
    let burnItems = [];
    let burnPage = 0;

    function padTopicAddr(addr){
    return ethers.zeroPadValue(addr, 32);
    }

    function fmtTime(ms){
    return new Date(ms).toLocaleString();
    }

    function txUrl(hash){
    return `https://etherscan.io/tx/${hash}`;
    }

    async function loadBurnHistoryOnChain(){
    // needs provider + userAddress
    const logs = await provider.getLogs({
        address: DBXEN_ADDRESS,
        fromBlock: DBXEN_FROM_BLOCK,
        toBlock: "latest",
        topics: [DBXEN_BURN_TOPIC0, padTopicAddr(userAddress)]
    });

    // Burn event has 1 non-indexed uint256 in data = batches
    burnItems = await Promise.all(logs.map(async (log) => {
        const batches = Number(ethers.AbiCoder.defaultAbiCoder().decode(["uint256"], log.data)[0]);
        const xen = batches * XEN_PER_BATCH;

        let timeMs = Date.now();
        try{
        const blk = await provider.getBlock(log.blockNumber);
        if (blk?.timestamp) timeMs = Number(blk.timestamp) * 1000;
        }catch{}

        return {
        timeMs,
        batches,
        xen,
        txHash: log.transactionHash,
        blockNumber: log.blockNumber
        };
    }));

    // newest first
    burnItems.sort((a,b) => b.blockNumber - a.blockNumber);

    renderBurnTotals();
    renderBurnPage(0);
    }

    function renderBurnTotals(){
    const totX = document.getElementById("totXenBurned");
    if (!totX) return;

    const totalXen = burnItems.reduce((sum, it) => sum + it.xen, 0);
    totX.textContent = totalXen.toLocaleString("en-US");

    // For now: set earned totals to "â€”" until we wire lifetime earned
    const totD = document.getElementById("totDxnEarned");
    const totE = document.getElementById("totEthFees");
    if (totD) totD.textContent = "â€”";
    if (totE) totE.textContent = "â€”";
    }

    function renderBurnPage(pageIdx){
    const rowsEl = document.getElementById("burnRows");
    const pageEl = document.getElementById("burnPage");
    const pagesEl = document.getElementById("burnPages");
    if (!rowsEl || !pageEl || !pagesEl) return;

    const pages = Math.max(1, Math.ceil(burnItems.length / PAGE_SIZE));
    burnPage = Math.max(0, Math.min(pages - 1, pageIdx));

    pageEl.textContent = String(burnPage + 1);
    pagesEl.textContent = String(pages);

    const slice = burnItems.slice(burnPage * PAGE_SIZE, burnPage * PAGE_SIZE + PAGE_SIZE);

    if (slice.length === 0){
        rowsEl.innerHTML = `<div style="opacity:.7;">No burns found for this wallet.</div>`;
        return;
    }

    rowsEl.innerHTML = slice.map(it => `
        <div style="display:flex;justify-content:space-between;gap:12px;align-items:flex-start;border:1px solid rgba(255,255,255,.08);background:rgba(2,6,23,.25);padding:10px 12px;border-radius:12px;">
        <div style="display:grid;gap:6px;">
            <div style="font-weight:900;">${fmtTime(it.timeMs)}</div>
            <div style="opacity:.85;">Batches: <b>${it.batches.toLocaleString("en-US")}</b> â€¢ XEN: <b>${it.xen.toLocaleString("en-US")}</b></div>
        </div>
        <a class="btn-yellow" style="height:34px;border-radius:10px;padding:0 10px;font-size:12px;"
            target="_blank" rel="noopener" href="${txUrl(it.txHash)}">Tx</a>
        </div>
    `).join("");
    }

    // paging buttons
    const prevBtn = document.getElementById("burnPrev");
    const nextBtn = document.getElementById("burnNext");
    if (prevBtn) prevBtn.addEventListener("click", (e) => { e.preventDefault(); renderBurnPage(burnPage - 1); });
    if (nextBtn) nextBtn.addEventListener("click", (e) => { e.preventDefault(); renderBurnPage(burnPage + 1); });


  async function refreshFees() {
    if (!provider) {
      pfEl.textContent = "~";
      ttcEl.textContent = "~";
      return;
    }

    try {
      const b = clampBatches(batchInput.value);
      const { protocolFee, totalCost } = await calcDbxenFee(b);

      const sym = (cfg()?.nativeSymbol) || "ETH";
      pfEl.textContent  = "~ " + fmtEth(protocolFee) + " " + sym;
      ttcEl.textContent = "~ " + fmtEth(totalCost) + " " + sym;


      burnBtn.disabled = false;
      burnBtn.style.opacity = "1";
    } catch (e) {
      console.log("refreshFees failed:", e);
      pfEl.textContent = "~";
      ttcEl.textContent = "~";
      burnBtn.disabled = true;
      burnBtn.style.opacity = "0.6";
    }
  }

  async function burnXenNow() {
    if (!provider || !signer) { alert("Connect wallet first"); return; }

    const b = clampBatches(batchInput.value);
    const gasPrice = await getLegacyGasPriceWei();

    let gasUsed;
    try {
      const dbxenRead = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, provider);
      gasUsed = await dbxenRead.burnBatch.estimateGas(b, { value: 0n });
    } catch {
      gasUsed = 220000n;
    }

    const maxBps = 100000n;
    const discount = BigInt(b) * (maxBps - (5n * BigInt(b)));
    const protocolFee = ((gasUsed + 39400n) * gasPrice * discount) / maxBps;

    const valueToSend = (protocolFee * 130n) / 100n;

    const dbxenWrite = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, signer);

    const tx = await dbxenWrite.burnBatch(b, {
      value: valueToSend,
      gasPrice: gasPrice,
      type: 0
    });

    await tx.wait();
    await loadStakeInfo();
    setTimeout(loadStakeInfo, 2500);
  }

  async function getLegacyGasPriceWei() {
    const hex = await provider.send("eth_gasPrice", []);
    return BigInt(hex);
  }

  function parseDxnAmount(v) {
    const s = String(v || "").trim();
    if (!s) return 0n;
    return ethers.parseUnits(s, 18);
  }

  const stakeBtn = document.getElementById("stakeBtn");
  const unstakeBtn = document.getElementById("unstakeBtn");
  const stakeAmt = document.getElementById("stakeAmt");

  if (stakeBtn) {
    stakeBtn.addEventListener("click", async (e) => {
      e.preventDefault();
      if (!signer) return;

      try {
        const amtWei = parseDxnAmount(stakeAmt.value);
        if (amtWei <= 0n) {
          const fill = __dxnWalletWei;
          stakeAmt.value = fill > 0n ? ethers.formatUnits(fill, 18) : "";
          return;
        }

        const dxn = new ethers.Contract(DXN_ADDRESS, ERC20_ABI, signer);
        const allowance = await dxn.allowance(userAddress, DBXEN_ADDRESS);

        if (allowance < amtWei) {
          const MAX = (2n ** 256n) - 1n;
          const txA = await dxn.approve(DBXEN_ADDRESS, MAX);
          await txA.wait();
        }

        const gasPrice = await getLegacyGasPriceWei();
        const dbxen = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, signer);

        const tx = await dbxen.stake(amtWei, {
          gasPrice,
          type: 0,
          gasLimit: 250000n
        });

        await tx.wait();
        await loadStakeInfo();

      } catch (err) {
        console.log("STAKE ERROR:", err);
      }
    });
  }

  if (unstakeBtn) {
    unstakeBtn.addEventListener("click", async (e) => {
      e.preventDefault();
      if (!signer) return;

      try {
        const amtWei = parseDxnAmount(stakeAmt.value);
        if (amtWei <= 0n) {
          const fill = __dxnWithdrawableWei;
          stakeAmt.value = fill > 0n ? ethers.formatUnits(fill, 18) : "";
          return;
        }

        const gasPrice = await getLegacyGasPriceWei();
        const dbxen = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, signer);

        const tx = await dbxen.unstake(amtWei, { gasPrice, type: 0 });
        await tx.wait();

        await loadStakeInfo();
      } catch (err) {
        console.log("UNSTAKE ERROR:", err);
      }
    });
  }

  connectBtn.addEventListener("click", connectWallet);

  minusBtn.addEventListener("click", async (e) => {
    e.preventDefault();
    await setBatches(Number(batchInput.value) - 1);
    });

    plusBtn.addEventListener("click", async (e) => {
    e.preventDefault();
    await setBatches(Number(batchInput.value) + 1);
    });

    maxBtn.addEventListener("click", async (e) => {
    e.preventDefault();
    const mode = maxBtn.dataset.mode || "max";
    if (mode === "max") await setBatches(MAX_BATCHES);
    else await setBatches(1);
    });


  batchInput.addEventListener("input", async () => {
    renderXen();
    syncMaxBtnLabel();
    await refreshFees();
    });


  burnBtn.addEventListener("click", async (e) => {
    e.preventDefault();

    if (!provider || !signer) {
      return;
    }

    const b = clampBatches(batchInput.value);

    try {
      const xen = new ethers.Contract(XEN_ADDRESS, ERC20_ABI, signer);
      const needed = BigInt(b) * BigInt(XEN_PER_BATCH);

      const allowance = await xen.allowance(userAddress, DBXEN_ADDRESS);

      if (allowance < needed) {
        const MAX = (2n ** 256n) - 1n;

        const tx1 = await xen.approve(DBXEN_ADDRESS, MAX);
        await tx1.wait();
      }

      await burnXenNow();
    } catch (err) {
      console.log("BURN FLOW ERROR:", err);
    }
  });

  wireClaimButtons();

  burnBtn.disabled = true;
  burnBtn.style.opacity = "0.6";
  applyChainConfig();
  renderXen();
  syncMaxBtnLabel();

  window.addEventListener("load", async () => {
    if (!window.ethereum) return;

    const accts = await window.ethereum.request({ method: "eth_accounts" });
    if (!accts || accts.length === 0) return;

    // auto-connect
    try { await connectWallet(); } catch (e) { console.log("auto-connect failed", e); }
    });

  </script>
</body>
</html>
