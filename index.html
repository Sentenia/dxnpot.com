<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Burn XEN / Mint DXN</title>
  <link rel="icon" type="image/png" href="favicon.png">
  <style>
    :root{
      --bg1:#050814;
      --bg2:#020617;
      --card1:#0b1220;
      --card2:#020617;
      --line:#2a3446;
      --line2:#1c2433;
      --txt:#e5e7eb;
      --muted:#9ca3af;
      --muted2:#7b8495;
      --yellow:#facc15;
      --yellow2:#f59e0b;
      --black:#000;
    }

    *{ box-sizing:border-box; }

    body{
      margin:0;
      font-family: Arial, sans-serif;
      color:var(--txt);
      background: url("dxn-bg.png") center / cover no-repeat fixed;
      padding:40px 18px;
    }

    /* outer glass frame */
    .frame{
      max-width: 820px;
      margin: 0 auto;
      padding: 22px;
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,.22);
      background: rgba(2,6,23,.35);
      box-shadow: 0 10px 40px rgba(0,0,0,.55), inset 0 0 0 1px rgba(255,255,255,.04);
      width: 100%;
      overflow: hidden;
    }


    .topbar{
      display:flex;
      justify-content: space-between;
     
      margin-bottom: 18px;
    }




    .pill{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 12px 16px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.25);
      background: rgba(2,6,23,.55);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
      min-height: 44px;
      white-space:nowrap;
      width: fit-content;
      height: 44px;
      min-width: 220px;
    }

    .topbar { align-items: center; }

  


    .pill .dot{
      width: 12px;
      height: 12px;
      border-radius: 999px;
      background: #60a5fa;
      box-shadow: 0 0 14px rgba(96,165,250,.5);
    }

    .pill-right{
      border-color: rgba(250,204,21,.35);
    }

    .title{
      text-align:center;
      font-size: 34px;
      font-weight: 700;
      letter-spacing:.2px;
      margin: 18px 0 10px;
    }

    .subline{
      display:flex;
      justify-content:center;
      gap: 60px;
      font-size: 18px;
      color: var(--muted);
      margin-bottom: 18px;
    }

    .subline b{
      color: var(--yellow);
      font-weight:700;
    }

    /* cards */
    .card{
      background: linear-gradient(180deg, rgba(11,18,32,.85), rgba(2,6,23,.85));
      border: 1px solid rgba(148,163,184,.20);
      border-radius: 16px;
      padding: 18px 18px 16px;
      box-shadow:
        0 10px 30px rgba(0,0,0,.35),
        inset 0 0 0 1px rgba(255,255,255,.03);
      margin-top: 16px;
    }

    .card-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom: 12px;
    }

    .card-header .label{
      font-size: 18px;
      font-weight: 700;
      color: var(--txt);
    }

    .card-header .maxhint{
      font-size: 13px;
      color: var(--muted2);
      letter-spacing:.3px;
    }
    .card-header .maxhint b{ color: var(--yellow); }

    .controls{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap: wrap;
    }


    .btn{
      border: 1px solid rgba(148,163,184,.22);
      background: rgba(2,6,23,.7);
      color: var(--txt);
      border-radius: 10px;
      padding: 10px 14px;
      font-size: 18px;
      cursor:pointer;
      min-width: 46px;
      height: 44px;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .btn-yellow{
      background: linear-gradient(180deg, var(--yellow), var(--yellow2));
      border: 0;
      color: var(--black);
      font-weight: 800;
      border-radius: 10px;
      padding: 10px 16px;
      cursor:pointer;
      height: 44px;
      box-shadow: 0 8px 20px rgba(250,204,21,.22);
    }

    .input{
      width: 72px;
      height: 44px;
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,.22);
      background: rgba(2,6,23,.65);
      color: var(--txt);
      text-align:center;
      font-size: 18px;
      outline:none;
    }

    .xenbox{
      flex: 1 1 220px;
      height: 44px;
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,.22);
      background: rgba(2,6,23,.65);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 22px;
      letter-spacing:.2px;
      min-width: 220px;
    }


    .smallnote{
      margin-top: 10px;
      font-size: 14px;
      color: var(--muted);
    }

    .smallnote.row-between{
      display:flex;
      justify-content: space-between;
      align-items:center;
      width:100%;
    }


    .divider{
      height:1px;
      background: rgba(148,163,184,.18);
      margin: 12px 0 12px;
    }

    .lines{
      font-size: 16px;
      color: var(--muted);
      line-height: 1.9;
    }

    .lines .v{
      color: var(--yellow);
      font-weight: 700;
    }

    .burnbtn{
      margin-top: 14px;
      width: 100%;
      height: 56px;
      border-radius: 12px;
      font-size: 20px;
      font-weight: 900;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 10px;
    }

    .rows{
      margin-top: 14px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .rowcard{
      border: 1px solid rgba(148,163,184,.18);
      background: rgba(2,6,23,.55);
      border-radius: 14px;
      padding: 14px 16px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 14px;
    }

    .rowcard .left{
      font-size: 18px;
      color: var(--txt);
    }
    .rowcard .left b{
      color: var(--yellow);
    }

    .row-actions{
      display:flex;
      gap: 10px;
      align-items:center;
    }

    .sub-under{
      margin-top: 10px;
      text-align:right;
      color: var(--muted2);
      font-size: 14px;
    }

    .bottomlinks{
      text-align:center;
      margin-top: 18px;
      color: var(--muted2);
      font-size: 14px;
      letter-spacing:.4px;
      width: 100%;
    }

  
    .bottomlinks a{
      color: var(--muted2);
      text-decoration:none;
      border-bottom: 1px solid rgba(148,163,184,.25);
      padding-bottom: 2px;
    }
    .bottomlinks a:hover{ color: var(--txt); border-bottom-color: rgba(229,231,235,.35); }

    @media (max-width: 640px){
      .subline{ gap: 20px; font-size: 16px; flex-wrap:wrap; }
      .title{ font-size: 28px; }
      .controls{ flex-wrap:wrap; }
      .xenbox{ min-width: 180px; }
    }

    .contract-links{
      text-align:center;
    }

    .copy-pill{
      display:inline-block;
      margin-top:10px;
      padding:8px 12px;
      border-radius:999px;
      background: linear-gradient(180deg, var(--yellow), var(--yellow2));
      color:#000;
      font-weight:800;
      font-size:12px;
      letter-spacing:.2px;
      box-shadow: 0 8px 20px rgba(250,204,21,.22);
    }

    #chainPill{
      position: relative;
      cursor: pointer;
    }

    #chainSelect{
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    .chain-pill{ position:relative; cursor:pointer; }

    .chain-menu{
      position:absolute;
      top: 52px;
      left: 0;
      width: 220px;
      padding: 8px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,.25);
      background: rgba(2,6,23,.55);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.03);
      z-index: 999;
    }

    .chain-item{
      width:100%;
      text-align:left;
      padding: 10px 12px;
      border:0;
      border-radius:10px;
      background: transparent;
      color: var(--txt);
      cursor:pointer;
      font-size: 14px;
    }
    .chain-item:hover{
      background: rgba(255,255,255,.06);
    }

    .row-between{
      display:flex;
      justify-content: space-between;
      align-items:center;
    }

    .rowcard.stakeRow{ align-items:flex-start; }
    .rowcard.stakeRow .left{ flex: 1; }
    .rowcard.stakeRow .right{
      margin-left:auto;
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:8px;
    }



  </style>
</head>

<body>
  <div class="frame">

    <!-- top pills -->
    <div class="topbar">
      <div class="pill chain-pill" id="chainPill">
  <span class="dot"></span>
  <span id="chainLabel">Ethereum</span>
  <span class="chev">‚ñº</span>

  <div class="chain-menu" id="chainMenu" style="display:none;">
    <button class="chain-item" data-chain="eth">Ethereum</button>
    <button class="chain-item" data-chain="soon">More chains soon</button>
  </div>
</div>


      
        
      <div class="pill pill-right">
        <span style="color:var(--yellow);font-weight:800;">‚óÜ</span>
        <span id="ethBal" style="color:var(--txt);">‚Äî ETH</span>
        <span id="addrShort" style="opacity:.8;">Not connected</span>
        <button id="connectBtn" class="btn-yellow" style="height:34px;padding:6px 10px;border-radius:10px;font-weight:800;">
            Connect
        </button>
        </div>
        </div>


    <!-- title -->
    <div class="title">Burn XEN / Mint DXN</div>

    <!-- cycle line -->
    <div class="subline">
      <div>Current Cycle: <b id="currentCycle">‚Äî</b></div>
      <div>DXN Minted This Cycle: <b id="dxnMintedCycle">‚Äî</b></div>
    </div>

    <!-- burn card -->
    <div class="card">
      <div class="card-header">
        <div class="label">Burn Batches</div>
        <div class="maxhint">MAX: <b>10,000</b> BATCHES</div>
      </div>

      <!-- IMPORTANT: one minus + one plus only (XEN box adjusts with batches) -->
      <div class="controls">
        <input id="batchInput" class="input" type="number" value="1" min="1" max="10000" />

        <button id="minusBtn" class="btn-yellow">‚àí</button>

        <div class="xenbox">
            <span id="xenAmount">2,500,000</span> <span style="opacity:.85;">XEN</span>
        </div>

        <button id="plusBtn" class="btn-yellow">+</button>

        <button id="maxBtn" class="btn-yellow">‚¨Ü Max</button>
        </div>



      <div class="smallnote row-between">
        <span>1 Batch = 2,500,000 XEN</span>
        <span>Your XEN: <b id="yourXen">‚Äî</b></span>
      </div>

      <div class="divider"></div>

      <div class="lines">
        Protocol Fee : <span id="pf" class="v">~</span><br />
        Total Transaction Cost: <span id="ttc" class="v">~</span><br />
        Total XEN Burned : <span id="totalXenBurned" class="v">2,500,000</span>
        </div>


      <button class="btn-yellow burnbtn">üî• Burn XEN</button>
    </div>

    <!-- rows -->
    <div class="rows">
      <div class="rowcard">
        <div class="left">
          Auto-staked DXN: <b id="autoDxnVal">‚Äî</b> <span style="opacity:.85;">DXN</span>
        </div>
        <button id="claimDxnBtn" class="btn-yellow" style="min-width:140px;">Claim</button>
      </div>


      <div class="rowcard">
        <div class="left">
          Claimable ETH: <b id="claimableEthVal">‚Äî</b> <span style="opacity:.85;">ETH</span>
        </div>
        <button id="claimEthBtn" class="btn-yellow" style="min-width:140px;">Claim</button>
      </div>


      <div class="rowcard stakeRow">
        <div class="left" style="padding-top:2px; line-height:1.15;">
          <div>
            Total Staked:
            <b id="totalStakedVal" class="tip" data-tip="Available to withdraw this cycle">‚Äî</b>
            <span style="opacity:.85;">DXN</span>
          </div>

          <div style="margin-top:6px; color:var(--muted2); font-size:14px;">
            Total Pending:
            <b id="pendingStakedVal" class="tip" data-tip="Locked until next cycle">‚Äî</b>
            <span style="opacity:.85;">DXN</span>
          </div>
        </div>

        <div class="right">
          <div class="row-actions">
            <input id="stakeAmt" class="input" type="number" placeholder="0.0" min="0" step="any" style="width:120px;" />
            <button id="stakeBtn" class="btn-yellow" style="min-width:130px;">Stake</button>
            <button id="unstakeBtn" class="btn-yellow" style="min-width:130px;">Unstake</button>
          </div>
          <div class="sub-under">Your DXN: <span id="yourDxnBal">‚Äî</span> DXN</div>
        </div>
      </div>


    <!-- bottom contract links -->
    <div class="bottomlinks">
      <div class="contract-links">
        <a href="#" id="copyXen">XEN Contract</a>
        &nbsp; | &nbsp;
        <a href="#" id="copyDxn">DXN Contract</a>
      </div>

      <div id="copyMsg" class="copy-pill" style="display:none;"></div>
    </div>


  </div>
 

  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.4/dist/ethers.umd.min.js"></script>

<script>

  const ERC20_ABI = [
  "function balanceOf(address) view returns (uint256)",
  "function allowance(address owner, address spender) view returns (uint256)",
  "function approve(address spender, uint256 amount) returns (bool)",
  "function decimals() view returns (uint8)"
];

  function wireClaimButtons() {
    const claimDxnBtn = document.getElementById("claimDxnBtn");
    const claimEthBtn = document.getElementById("claimEthBtn");

    console.log("wireClaimButtons:", {
      claimDxnBtn: !!claimDxnBtn,
      claimEthBtn: !!claimEthBtn
    });

    if (claimDxnBtn && !claimDxnBtn.__wired) {
      claimDxnBtn.__wired = true;
      claimDxnBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        if (!signer) return;

        try {
          const gasPrice = await getLegacyGasPriceWei();
          const dbxenWrite = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, signer);

          const tx = await dbxenWrite.claimRewards({ gasPrice, type: 0 });
          await tx.wait();

          await loadClaimables();
        } catch (err) {
          console.log("CLAIM DXN ERROR:", err);
        }
      });
    }

    if (claimEthBtn && !claimEthBtn.__wired) {
      claimEthBtn.__wired = true;
      claimEthBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        if (!signer) return;

        try {
          const gasPrice = await getLegacyGasPriceWei();
          const dbxenWrite = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, signer);

          const tx = await dbxenWrite.claimFees({ gasPrice, type: 0 });
          await tx.wait();

          await loadClaimables();
        } catch (err) {
          console.log("CLAIM ETH ERROR:", err);
        }
      });
    }
  }



  const chainPill = document.getElementById("chainPill");
  const chainMenu = document.getElementById("chainMenu");
  const chainLabel = document.getElementById("chainLabel");

  chainPill.addEventListener("click", (e) => {
    e.stopPropagation();
    chainMenu.style.display = (chainMenu.style.display === "none") ? "block" : "none";
  });

  document.addEventListener("click", () => {
    chainMenu.style.display = "none";
  });

  document.querySelectorAll(".chain-item").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.preventDefault();
      chainLabel.textContent = btn.textContent;
      chainMenu.style.display = "none";
    });
  });

  const XEN_ADDRESS = "0x06450dee7fd2fb8e39061434babcfc05599a6fb8";
  const DXN_ADDRESS = "0x80f0c1c49891dcfdd40b6e0f960f84e6042bcb6f";

  const copyXen = document.getElementById("copyXen");
  const copyDxn = document.getElementById("copyDxn");
  const copyMsg = document.getElementById("copyMsg");

  function showCopied(text){
    copyMsg.textContent = text;
    copyMsg.style.display = "inline-block";
    copyMsg.style.opacity = "1";

    clearTimeout(window.__copyTimer);
    window.__copyTimer = setTimeout(() => {
      copyMsg.style.opacity = "0";
      setTimeout(() => { copyMsg.style.display = "none"; }, 250);
    }, 1200);
  }


  async function copyToClipboard(addr){
    try{
      await navigator.clipboard.writeText(addr);
      showCopied("Address copied to clipboard");
    }catch(e){
      // fallback for older browsers
      const ta = document.createElement("textarea");
      ta.value = addr;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      document.body.removeChild(ta);
      showCopied("Address copied to clipboard");
    }
  }


  copyXen.addEventListener("click", (e) => {
    e.preventDefault();
    copyToClipboard(XEN_ADDRESS);
  });

  copyDxn.addEventListener("click", (e) => {
    e.preventDefault();
    copyToClipboard(DXN_ADDRESS);
  });


  // ===== UI CONSTANTS =====
  const XEN_PER_BATCH = 2500000;
  const MAX_BATCHES = 10000;

  // ===== DBXEN MAIN CONTRACT =====
  const DBXEN_ADDRESS = "0xF5c80c305803280B587F8cabBcCdC4d9BF522AbD";

  // NOTE: This ABI is intentionally a SUPerset to avoid breaking calls
  // while we migrate reads/writes to the correct contract (main vs reader).
  const DBXEN_ABI = [
    // ---- writes (main) ----
    "function burnBatch(uint256 batches) payable",
    "function claimFees()",
    "function claimRewards()",
    "function stake(uint256 amount)",
    "function unstake(uint256 amount)",

    // ---- fee / constants (main) ----
    "function MAX_BPS() view returns (uint256)",

    // ---- cycle (main) ----
    "function currentCycle() view returns (uint256)",
    "function getCurrentCycle() view returns (uint256)",
    "function currentCycleReward() view returns (uint256)",
    "function lastCycleReward() view returns (uint256)",
    "function rewardPerCycle(uint256) view returns (uint256)",

    // ---- stake accounting (main) ----
    // Real name (from your read tab)
    "function accWithdrawableStake(address account) view returns (uint256)",
    "function pendingStake() view returns (uint256)",
    "function pendingStakeWithdrawal() view returns (uint256)",
    "function accRewards(address account) view returns (uint256)",



    // Legacy/alias names (keep to prevent breakage if referenced anywhere)
    "function getAccWithdrawableStake(address staker) view returns (uint256)",

    // ---- legacy/reader-like getters (keep for now; we prefer the READER contract) ----
    "function getUnclaimedRewards(address account) view returns (uint256)",
    "function getUnclaimedFees(address account) view returns (uint256)",

    // ---- legacy experiment (keep if any old code still calls it) ----
    "function calculateCycleReward() view returns (uint256)",
    "function dxnMintedInCycle(uint256 cycle) view returns (uint256)",

    "function accFirstStake(address) view returns (uint256)",
    "function accSecondStake(address) view returns (uint256)",
    "function accStakeCycle(address,uint256) view returns (uint256)",
    "function getUnclaimedRewards(address) view returns (uint256)",
    "function getUnclaimedFees(address) view returns (uint256)",

  ];

  // ===== DBXEN READER (HELPER CONTRACT) =====
  const DBXEN_READER_ADDRESS = "0xf032f7FB8258728A1938473B2115BB163d5Da593";

  const DBXEN_READER_ABI = [
    "function dbxen() view returns (address)",
    "function calculateCycleReward() view returns (uint256)",
    "function getUnclaimedFees(address account) view returns (uint256)",
    "function getUnclaimedRewards(address account) view returns (uint256)"
  ];



  const FEE_GAS_PAD = 39400n;
  const BATCH_SLOPE = 5n;

  // ===== UI ELEMENTS =====
  const batchInput = document.getElementById("batchInput");
  const minusBtn = document.getElementById("minusBtn");
  const plusBtn = document.getElementById("plusBtn");
  const maxBtn = document.getElementById("maxBtn");

  const xenAmountEl = document.getElementById("xenAmount");
  const totalXenBurnedEl = document.getElementById("totalXenBurned");

  const pfEl = document.getElementById("pf");
  const ttcEl = document.getElementById("ttc");

  const connectBtn = document.getElementById("connectBtn");
  const addrShort = document.getElementById("addrShort");
  const ethBal = document.getElementById("ethBal");

  const burnBtn = document.querySelector(".burnbtn");



  // ===== STATE =====
  let provider = null;
  let signer = null;
  let userAddress = null;

  function clampBatches(n) {
    n = Math.floor(Number(n || 1));
    if (n < 1) n = 1;
    if (n > MAX_BATCHES) n = MAX_BATCHES;
    return n;
  }

  function fmtInt(n) {
    return Number(n).toLocaleString("en-US");
  }

  function shortAddr(a) {
    return a ? (a.slice(0, 6) + "‚Ä¶" + a.slice(-4)) : "Not connected";
  }

  function renderXen() {
    const b = clampBatches(batchInput.value);
    batchInput.value = b;

    const xen = b * XEN_PER_BATCH;
    xenAmountEl.textContent = fmtInt(xen);
    totalXenBurnedEl.textContent = fmtInt(xen);
  }

  async function connectWallet() {
    if (!window.ethereum) {
      return;
    }
    provider = new ethers.BrowserProvider(window.ethereum);
    await provider.send("eth_requestAccounts", []);
    signer = await provider.getSigner();
    userAddress = await signer.getAddress();

    addrShort.textContent = shortAddr(userAddress);

    const balWei = await provider.getBalance(userAddress);
    ethBal.textContent = Number(ethers.formatEther(balWei)).toFixed(4) + " ETH";

    await refreshFees(); // start showing fees immediately
    await loadXenBalance();
    await loadCycleStats();
    await loadClaimables();
    await loadStakeInfo();

    wireClaimButtons();

  }

  async function loadStakeInfo() {
    const totalEl = document.getElementById("totalStakedVal");
    const pendingEl = document.getElementById("pendingStakedVal");
    const balEl = document.getElementById("yourDxnBal");

    if (totalEl) totalEl.textContent = "‚Ä¶";
    if (pendingEl) pendingEl.textContent = "‚Ä¶";
    if (balEl) balEl.textContent = "‚Ä¶";

    if (!provider || !userAddress) {
      if (totalEl) totalEl.textContent = "‚Äî";
      if (pendingEl) pendingEl.textContent = "‚Äî";
      if (balEl) balEl.textContent = "‚Äî";
      return;
    }

    // helper: never throw
    const safe = async (fn, fallback) => {
      try { return await fn(); } catch (e) { console.log("loadStakeInfo safe fail:", e); return fallback; }
    };

    // DXN wallet balance
    await safe(async () => {
      const dxn = new ethers.Contract(DXN_ADDRESS, ERC20_ABI, provider);
      const dec = await dxn.decimals();
      const bal = await dxn.balanceOf(userAddress);
      if (balEl) balEl.textContent = ethers.formatUnits(bal, dec);
    }, null);

    // Stake totals (replicate DBXEN staking shape)
    await safe(async () => {
      const dbxen = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, provider);

      // withdrawable (available now)
      const withdrawable = await dbxen.accWithdrawableStake(userAddress);

      // pending (locked until next cycle)
      const cycle = await dbxen.currentCycle();
      const pending = await dbxen.accStakeCycle(userAddress, cycle + 1n);

      const total = withdrawable + pending;

      if (totalEl) totalEl.textContent = ethers.formatUnits(total, 18);
      if (pendingEl) pendingEl.textContent = ethers.formatUnits(pending, 18);
    }, (() => {
      if (totalEl) totalEl.textContent = "‚Äî";
      if (pendingEl) pendingEl.textContent = "‚Äî";
    })());
  }


  async function loadClaimables_MAIN_OLD() {
    const dxnEl = document.getElementById("autoDxnVal");
    const ethEl = document.getElementById("claimableEthVal");

    if (dxnEl) dxnEl.textContent = "‚Ä¶";
    if (ethEl) ethEl.textContent = "‚Ä¶";

    try {
      if (!provider || !userAddress) {
        if (dxnEl) dxnEl.textContent = "‚Äî";
        if (ethEl) ethEl.textContent = "‚Äî";
        return;
      }

      const dbxen = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, provider);

      // DXN claimable
      try {
        const dxnWei = await dbxen.getUnclaimedRewards(userAddress);
        if (dxnEl) dxnEl.textContent = fmtDXN(dxnWei); // you already have fmtDXN()
      } catch (e) {
        console.log("getUnclaimedRewards reverted:", e);
        if (dxnEl) dxnEl.textContent = "‚Äî";
      }

      // ETH claimable
      try {
        const feeWei = await dbxen.getUnclaimedFees(userAddress);
        if (ethEl) ethEl.textContent = fmtEth(feeWei); // your fmtEth returns string number
      } catch (e) {
        console.log("getUnclaimedFees reverted:", e);
        if (ethEl) ethEl.textContent = "‚Äî";
      }

    } catch (e) {
      console.log("loadClaimables failed:", e);
      if (dxnEl) dxnEl.textContent = "‚Äî";
      if (ethEl) ethEl.textContent = "‚Äî";
    }
  }
  
  async function loadCycleStats() {
    const cycleEl = document.getElementById("currentCycle");
    const mintedEl = document.getElementById("dxnMintedCycle");

    if (cycleEl) cycleEl.textContent = "‚Ä¶";
    if (mintedEl) mintedEl.textContent = "‚Ä¶";

    if (!provider) {
      if (cycleEl) cycleEl.textContent = "‚Äî";
      if (mintedEl) mintedEl.textContent = "‚Äî";
      return;
    }

    // cycle comes from main DBXen (you already proved this works)
    try {
      const dbxen = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, provider);
      const cycle = await dbxen.currentCycle.staticCall();
      if (cycleEl) cycleEl.textContent = cycle.toString();
    } catch (e) {
      console.log("currentCycle() failed:", e);
      if (cycleEl) cycleEl.textContent = "‚Äî";
      if (mintedEl) mintedEl.textContent = "‚Äî";
      return;
    }

    // ‚ÄúDXN Minted This Cycle‚Äù comes from the reader (calculateCycleReward)
    try {
      const reader = new ethers.Contract(DBXEN_READER_ADDRESS, DBXEN_READER_ABI, provider);

      // optional sanity check (can leave in)
      const main = await reader.dbxen();
      console.log("reader.dbxen() =>", main);

      const rewardWei = await reader.calculateCycleReward();
      if (mintedEl) mintedEl.textContent = fmtDXN(rewardWei);
    } catch (e) {
      console.log("calculateCycleReward (reader) failed:", e);
      if (mintedEl) mintedEl.textContent = "‚Äî";
    }
  }

  async function loadClaimables() {
    const dxnEl = document.getElementById("autoDxnVal");
    const ethEl = document.getElementById("claimableEthVal");

    if (dxnEl) dxnEl.textContent = "‚Ä¶";
    if (ethEl) ethEl.textContent = "‚Ä¶";

    if (!provider || !userAddress) {
      if (dxnEl) dxnEl.textContent = "‚Äî";
      if (ethEl) ethEl.textContent = "‚Äî";
      return;
    }

    try {
      const reader = new ethers.Contract(DBXEN_READER_ADDRESS, DBXEN_READER_ABI, provider);

      const feesWei = await reader.getUnclaimedFees(userAddress);
      const rewardsWei = await reader.getUnclaimedRewards(userAddress);

      console.log("reader fees eth:", ethers.formatEther(feesWei));
      console.log("reader rewards dxn:", ethers.formatUnits(rewardsWei, 18));

      if (ethEl) ethEl.textContent = ethers.formatEther(feesWei);        // raw accurate
      if (dxnEl) dxnEl.textContent = ethers.formatUnits(rewardsWei, 18); // raw accurate
    } catch (e) {
      console.log("loadClaimables failed:", e);
      if (dxnEl) dxnEl.textContent = "‚Äî";
      if (ethEl) ethEl.textContent = "‚Äî";
    }
  }


  async function loadXenBalance(){
    const el = document.getElementById("yourXen");
    if (!el) return;

    el.textContent = "‚Ä¶"; // loading

    try{
      if (!provider || !userAddress) { el.textContent = "‚Äî"; return; }

      const xen = new ethers.Contract(XEN_ADDRESS, ERC20_ABI, provider);
      const decimals = await xen.decimals();
      const bal = await xen.balanceOf(userAddress);

      el.textContent = Number(ethers.formatUnits(bal, decimals)).toLocaleString();
    }catch(err){
      console.log("XEN BAL ERROR:", err);
      el.textContent = "ERR";
    }
  }


  async function getGasPriceWei() {
    const hex = await provider.send("eth_gasPrice", []);
    return BigInt(hex);
  }

  

  async function calcDbxenFee(batches) {
    
    const dbxenRead = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, provider);
    const maxBps = await dbxenRead.MAX_BPS();
    const b = BigInt(batches);
    const discount = b * (maxBps - (BATCH_SLOPE * b));
    const gasPrice = await getGasPriceWei();
    if (!gasPrice) throw new Error("No gasPrice");
    let gasUsed;
    try {
      gasUsed = await dbxenRead.burnBatch.estimateGas(batches, { from: userAddress, value: 0n });
    } catch {
      // dbXen-style fallback so fee always shows
      gasUsed = 220000n;
    }


    const protocolFee =
      ((gasUsed + FEE_GAS_PAD) * gasPrice * discount) / maxBps;

    const totalCost = protocolFee + (gasUsed * gasPrice);

    return { protocolFee, totalCost };
  }

  function fmtEth(wei) {
    try {
      const s = ethers.formatEther(wei); // string
      const n = Number(s);
      if (!isFinite(n)) return "~";
      return n.toFixed(5); // ‚Üê 5 decimals like 0.00001
    } catch {
      return "~";
    }
  }

  function fmtDXN(wei) {
    const s = ethers.formatUnits(wei, 18); // DXN = 18 decimals
    const [i, d = ""] = s.split(".");
    return i + "." + d.slice(0, 7).padEnd(7, "0");
  }



  async function refreshFees() {
    if (!provider) {
      pfEl.textContent = "~";
      ttcEl.textContent = "~";
      return;
    }


    try {
      const b = clampBatches(batchInput.value);
      const { protocolFee, totalCost } = await calcDbxenFee(b);

      pfEl.textContent = "~ " + fmtEth(protocolFee) + " ETH";
      ttcEl.textContent = "~ " + fmtEth(totalCost) + " ETH";

      burnBtn.disabled = false;
      burnBtn.style.opacity = "1";
    } catch {
      pfEl.textContent = "~";
      ttcEl.textContent = "~";
      burnBtn.disabled = true;
      burnBtn.style.opacity = "0.6";
    }
  }

  async function needsXenApproval(batches){
    const xen = new ethers.Contract(XEN_ADDRESS, ERC20_ABI, provider);
    const needed = BigInt(batches) * BigInt(XEN_PER_BATCH);
    const allowance = await xen.allowance(userAddress, DBXEN_ADDRESS);
    return allowance < needed;
  }

  async function burnXenNow() {
    if (!provider || !signer) { alert("Connect wallet first"); return; }

    const b = clampBatches(batchInput.value);

    // use legacy gasPrice so tx.gasprice == this
    const gasPrice = await getLegacyGasPriceWei();

    // estimate gas (ok to use fallback if estimate reverts)
    let gasUsed;
    try {
      const dbxenRead = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, provider);
      gasUsed = await dbxenRead.burnBatch.estimateGas(b, { value: 0n });
    } catch {
      gasUsed = 220000n;
    }

    // exact contract formula
    const maxBps = 100000n;
    const discount = BigInt(b) * (maxBps - (5n * BigInt(b)));
    const protocolFee = ((gasUsed + 39400n) * gasPrice * discount) / maxBps;

    // buffer
    const valueToSend = (protocolFee * 130n) / 100n;

    const dbxenWrite = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, signer);

    const tx = await dbxenWrite.burnBatch(b, {
      value: valueToSend,
      gasPrice: gasPrice, // force legacy pricing
      type: 0
    });

    await tx.wait();
    await loadStakeInfo();
    setTimeout(loadStakeInfo, 2500);


  }


  async function getLegacyGasPriceWei() {
    const hex = await provider.send("eth_gasPrice", []);
    return BigInt(hex);
  }
  function parseDxnAmount(v) {
      const s = String(v || "").trim();
      if (!s) return 0n;
      return ethers.parseUnits(s, 18);
    }

    async function ensureDxnApproval(requiredWei) {
      const dxn = new ethers.Contract(DXN_ADDRESS, ERC20_ABI, signer);
      const allowance = await dxn.allowance(userAddress, DBXEN_ADDRESS);
      if (allowance >= requiredWei) return;

      const MAX = (2n ** 256n) - 1n;
      const tx = await dxn.approve(DBXEN_ADDRESS, MAX);
      await tx.wait();
    }

    const stakeBtn = document.getElementById("stakeBtn");
    const unstakeBtn = document.getElementById("unstakeBtn");
    const stakeAmt = document.getElementById("stakeAmt");

    if (stakeBtn) {
      stakeBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        if (!signer) return;

        try {
          const amtWei = parseDxnAmount(stakeAmt.value);
          if (amtWei <= 0n) return alert("Enter DXN amount");

          // 1) Approve if needed
          const dxn = new ethers.Contract(DXN_ADDRESS, ERC20_ABI, signer);
          const allowance = await dxn.allowance(userAddress, DBXEN_ADDRESS);

          if (allowance < amtWei) {
            const MAX = (2n ** 256n) - 1n;
            const txA = await dxn.approve(DBXEN_ADDRESS, MAX);
            await txA.wait();
          }

          // 2) Stake (force tx without estimateGas blocking MM)
          const gasPrice = await getLegacyGasPriceWei();
          const dbxen = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, signer);

          const tx = await dbxen.stake(amtWei, {
            gasPrice,
            type: 0,
            gasLimit: 250000n
          });

          await tx.wait();
          await loadStakeInfo();

        } catch (err) {
          console.log("STAKE ERROR:", err);
        }

      });
    }

    if (unstakeBtn) {
      unstakeBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        if (!signer) return;

        try {
          const amtWei = parseDxnAmount(stakeAmt.value);
          if (amtWei <= 0n) return alert("Enter DXN amount");

          const gasPrice = await getLegacyGasPriceWei();
          const dbxen = new ethers.Contract(DBXEN_ADDRESS, DBXEN_ABI, signer);

          const tx = await dbxen.unstake(amtWei, { gasPrice, type: 0 });
          await tx.wait();

          await loadStakeInfo();
        } catch (err) {
          console.log("UNSTAKE ERROR:", err);
        }
      });
    }
  // ===== EVENTS =====
  connectBtn.addEventListener("click", connectWallet);

  minusBtn.addEventListener("click", async () => {
    batchInput.value = clampBatches(Number(batchInput.value) - 1);
    renderXen();
    await refreshFees();
  });

  plusBtn.addEventListener("click", async () => {
    batchInput.value = clampBatches(Number(batchInput.value) + 1);
    renderXen();
    await refreshFees();
  });

  maxBtn.addEventListener("click", async () => {
    batchInput.value = MAX_BATCHES;
    renderXen();
    await refreshFees();
  });

  batchInput.addEventListener("input", async () => {
    renderXen();
    await refreshFees();
  });

  burnBtn.addEventListener("click", async (e) => {
    e.preventDefault();

    if (!provider || !signer) {
      return;
    }

    const b = clampBatches(batchInput.value);

    // If not approved, approve then auto-burn
    try {
      const xen = new ethers.Contract(XEN_ADDRESS, ERC20_ABI, signer);
      const needed = BigInt(b) * BigInt(XEN_PER_BATCH);

      const allowance = await xen.allowance(userAddress, DBXEN_ADDRESS);

      if (allowance < needed) {
        // approve max so you never approve again
        const MAX = (2n ** 256n) - 1n;

        const tx1 = await xen.approve(DBXEN_ADDRESS, MAX);
        await tx1.wait();
      }

      await burnXenNow();
    } catch (err) {
      console.log("BURN FLOW ERROR:", err);
    }
  });

  wireClaimButtons();

  // ===== INIT =====
  burnBtn.disabled = true;
  burnBtn.style.opacity = "0.6";
  renderXen();
  refreshFees();
</script>


</body>
</html>

